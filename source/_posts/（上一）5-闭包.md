---
title: （上一）5-闭包
date: 2018-03-01 19:44:45
tags: [你不知道的JS]
categories: 读书笔记
description: 你不知道的JS第五章节
---
<!-- more -->

### 闭包定义

**词法作用域**

理解词法作用域概念

**闭包**

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行

其具体表现为：
- 函数在定义时的词法作用域以外的地方被调用
- 函数持有对该作用域的引用，这个引用即为闭包

而且无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包

```
// 一个非常典型的例子

function foo() { 
    var a = 2;
    function bar() { 
        console.log( a );
    }
    return bar;
}
var baz = foo();
baz();      // 2  这就是闭包的效果。
```

闭包的神奇之处在于阻止了垃圾回收机制。正常一个函数执行后（`foo()`执行后），foo() 的整个内部作用域都被销毁，但因为 bar() 本身在使用内部作用域，因此内部作用域依然存在，因此没有被回收

### 应用场景

**回调函数**

本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。

在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包

**IIFE**

首先纠正一个常用技术立即执行函数（IIFE）

```
var a = 2;
(function IIFE() { 
    console.log( a );
})();
```
IIFE 从严格意义来讲它并不是闭包，因为函数并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行

尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建 可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用 闭包

**循环和闭包**

一个很常见的例子
```
for (var i=1; i<=5; i++) { 
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```
正常我们想每隔一秒分别打印12345，但实际上每隔一秒打印66666。这与 js 运行机制有关（event loop），setTimeout 为异步任务会在主线任务执行完毕后执行其回调，此时 i 已经变为 6。

解决办法一个是闭包
- IIFE 会通过声明并立即执行一个函数来创建作用域
```
for (var i=1; i<=5; i++) { 
    (function(j) {
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })(i);
}
```

另一种办法是实名 let 
- let 声明，可以用来劫 持块作用域

```
for (let i=1; i<=5; i++) { 
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```
for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量

**模块**
