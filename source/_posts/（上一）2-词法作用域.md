---
title: （上一）2-词法作用域
date: 2018-03-01 15:20:43
tags: [你不知道的JS]
categories: 读书笔记
description: 你不知道的JS第二章节
---
<!-- more -->

### 2.1 词法阶段

>大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。比如：无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定
- 词法作用域查找只会查找一级标识符

### 2.2 欺骗词法 

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词
法作用域

**eval**
```
function foo(str, a) { 
    eval( str );        // 欺骗! 
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
eval(..) 都在运行期修改书写期的词法作用域。eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域


**with**
```
function foo(obj) { 
    with (obj) {
    a = 2; }
}
var o1 = { a: 3};
var o2 = { b: 3};
foo( o1 );
console.log( o1.a );    // 2
foo( o2 );
console.log( o2.a );    // undefined
console.log( a );       // 2——不好，a 被泄漏到全局作用域上了!
```

with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域

>注：尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作 用域中。

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到 标识符

JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)


这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。